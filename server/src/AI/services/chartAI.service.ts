import { envConfig } from "@/config/env.config";
import { DataSourceDocument, SQLQueryData } from "@/interfaces/datasource.interface";
import { AiChart } from "@/AI/interface/aiChart.interface";
import { AiQuery } from "@/AI/interface/aiQuery.interface";
import { MODEL_TOOLS } from "@/AI/utils/modelTools";
import Anthropic from "@anthropic-ai/sdk";
import { Pool, PoolClient, QueryResult } from "pg";
import { DatasourceService } from "@/services/datasource.service";
import { base64Decoded } from "@/utils/utils";
import { GraphQLError } from "graphql";
import { ToolUseBlock } from "@anthropic-ai/sdk/resources";
import { CHART_PROMPTS } from "@/AI/prompts/chartPrompt";
import { generateChartPrompt, sqlGeneratorPrompt, sqlPromptMessage } from "@/AI/prompts/sqlPrompt";
import { SYSTEM_PROMPT } from "@/AI/prompts/systemPrompt";

const anthropicClient = new Anthropic({
  apiKey: envConfig.CLAUDE_API_KEY
});

export const generateChart = async (info: AiChart) => {
  let client: PoolClient | null = null;
  let pool: Pool | null = null;
  try {
    const { projectId, userPrompt, chartType } = info;
    console.log(`[START] Generating chart. Project ID: ${projectId}, Chart Type: ${chartType}`);

    let promptResult: ToolUseBlock | null = null;

    const project: DataSourceDocument = await DatasourceService.getDataSourceByProjectId(projectId);
    console.log(`[INFO] Retrieved project datasource for "${projectId}"`);

    const { databaseName, databaseUrl, username, password, port } = project;
    pool = pgPool(
      base64Decoded(databaseUrl!)!,
      base64Decoded(username!)!,
      base64Decoded(password!)!,
      port!,
      base64Decoded(databaseName!)!
    );
    client = await pool.connect();
    console.log(`[INFO] Connected to PostgreSQL database "${databaseName}"`);

    const schema: string = await getTableSchema(client);
    console.log(`[INFO] Fetched table schema:\n${schema}`);

    const content: string = sqlPromptMessage(schema, userPrompt);
    console.log(`[DEBUG] SQL prompt sent to AI:\n${content}`);

    const rawSQL: string = await aiSQLGenerator(content);
    const sql: string = rawSQL.replace(/```sql|```/g, '').trim();
    console.log(`[DEBUG] Generated SQL:\n${sql}`);

    const queryResult: QueryResult = await client.query(sql);
    console.log(`[SUCCESS] SQL executed. Returned ${queryResult.rows.length} rows`);

    if (queryResult.rows.length > 0) {
      const chartPrompt: string = CHART_PROMPTS[chartType as keyof typeof CHART_PROMPTS] || '';
      console.log(`[INFO] Chart prompt loaded for type: ${chartType}`);

      const message: string = generateChartPrompt(userPrompt, chartType, chartPrompt, JSON.stringify(queryResult.rows));
      console.log(`[DEBUG] Chart prompt to AI:\n${message}`);

      const response = await anthropicClient.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1024,
        temperature: 0.3,
        tools: MODEL_TOOLS,
        tool_choice: { type: 'auto' },
        messages: [{ role: 'user', content: message }],
        system: SYSTEM_PROMPT
      });

      const toolUseContent: Anthropic.Messages.ToolUseBlock | undefined = response.content.find(
        (res: Anthropic.Messages.ContentBlock) => res.type === 'tool_use'
      );

      promptResult = toolUseContent ? toolUseContent : null;
      console.log(`[SUCCESS] Chart generated by AI using tool_use`);
    }

    console.log(`[END] Chart generation complete.`);
    return {
      promptResult,
      queryResult: queryResult.rows,
      sql
    };
  } catch (error: any) {
    console.error(`[ERROR] generateChart failed: ${error.message}`);
    throw new GraphQLError(error?.message);
  } finally {
    if (client) {
      client.release();
      console.log(`[INFO] PostgreSQL client released`);
    }
    if (pool) {
      await pool.end();
      console.log(`[INFO] PostgreSQL connection pool closed`);
    }
  }
};

export const getSQLQueryData = async (data: AiQuery): Promise<SQLQueryData> => {
  let client: PoolClient | null = null;
  let pool: Pool | null = null;

  try {
    const { projectId, prompt } = data;
    console.log(`[START] getSQLQueryData for projectId: ${projectId}`);

    const project: DataSourceDocument = await DatasourceService.getDataSourceByProjectId(projectId);
    console.log(`[INFO] Retrieved datasource for project "${projectId}"`);

    const { databaseName, databaseUrl, username, password, port } = project;
    pool = pgPool(
      base64Decoded(databaseUrl!)!,
      base64Decoded(username!)!,
      base64Decoded(password!)!,
      port!,
      base64Decoded(databaseName!)!
    );

    client = await pool.connect();
    console.log(`[INFO] Connected to DB "${databaseName}"`);

    const schema: string = await getTableSchema(client);
    const message: string = sqlGeneratorPrompt(schema, prompt);
    console.log(`[DEBUG] SQL generation prompt:\n${message}`);

    const rawSQL: string = await aiSQLGenerator(message);
    const sql: string = rawSQL.replace(/```sql|```/g, '').trim();
    console.log(`[DEBUG] Generated SQL:\n${sql}`);

    const result: QueryResult = await client.query(sql);
    console.log(`[SUCCESS] SQL executed. Rows returned: ${result.rowCount}`);

    return { result: result.rows ?? [], sql };

  } catch (error: any) {
    console.error(`[ERROR] getSQLQueryData failed: ${error.message}`);
    throw new GraphQLError(error?.message);
  } finally {
    if (client) {
      client.release();
      console.log(`[INFO] PostgreSQL client released`);
    }
    if (pool) {
      await pool.end();
      console.log(`[INFO] PostgreSQL pool closed`);
    }
  }
};

const getTableSchema = async (client: PoolClient): Promise<string> => {
  console.log(`[INFO] Extracting table schema...`);
  const schemaQuery: string = `
    SELECT
      t.table_name,
      array_agg(
        c.column_name || ' ' || c.data_type ||
        CASE
          WHEN c.is_nullable = 'NO' THEN ' NOT NULL'
          ELSE ''
        END ||
        CASE
          WHEN EXISTS (
            SELECT 1 FROM information_schema.key_column_usage k
            WHERE k.table_name = t.table_name AND k.column_name = c.column_name
          ) THEN ' PRIMARY KEY'
          ELSE ''
        END ||
        CASE
          WHEN c.column_default IS NOT NULL THEN ' DEFAULT ' || c.column_default
          ELSE ''
        END
      ) as columns
    FROM
      information_schema.tables t
      JOIN information_schema.columns c ON t.table_name = c.table_name
    WHERE
      t.table_schema = 'public'
    GROUP BY
      t.table_name;
  `;
  const schema: QueryResult = await client.query(schemaQuery);
  console.log(`[INFO] Schema query executed successfully`);
  return schema.rows.map((row) => `Table ${row.table_name}:\n  ${row.columns.join(',\n  ')}`).join('\n\n');
};

const aiSQLGenerator = async (message: string): Promise<string> => {
  console.log(`[INFO] Calling Claude to generate SQL`);
  const sqlGeneration = await anthropicClient.messages.create({
    model: 'claude-sonnet-4-20250514',
    max_tokens: 1024,
    messages: [
      {
        role: 'user',
        content: message
      }
    ]
  });
  const sql: string = (sqlGeneration.content[0] as any).text.trim();
  console.log(`[SUCCESS] SQL generated by Claude`);
  return sql;
};

const pgPool = (host: string, username: string, password: string, port: string, dbName: string): Pool => {
  const pool: Pool = new Pool({
    host,
    user: username,
    password,
    port: parseInt(`${port}`, 10) ?? 5432,
    database: dbName,
    max: 20,
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 2000,
    maxUses: 7500
  });
  return pool;
};
